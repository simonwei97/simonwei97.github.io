<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://simonwei97.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://simonwei97.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-27T15:35:10+00:00</updated><id>https://simonwei97.github.io/feed.xml</id><title type="html">blank</title><subtitle>Simon Wei Blog. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Binary Tree different traversal ways</title><link href="https://simonwei97.github.io/blog/2023/binary-tree-traversal/" rel="alternate" type="text/html" title="Binary Tree different traversal ways"/><published>2023-09-11T15:09:00+00:00</published><updated>2023-09-11T15:09:00+00:00</updated><id>https://simonwei97.github.io/blog/2023/binary-tree-traversal</id><content type="html" xml:base="https://simonwei97.github.io/blog/2023/binary-tree-traversal/"><![CDATA[<h1 id="definition">Definition</h1> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">TreeNode</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Val</span>   <span class="kt">int</span>
    <span class="n">Left</span>  <span class="o">*</span><span class="n">TreeNode</span>
    <span class="n">Right</span> <span class="o">*</span><span class="n">TreeNode</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="preorder">Preorder</h1> <p>Access order: <code class="language-plaintext highlighter-rouge">Root -&gt; Left -&gt; Right</code>.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Recursion</span>
<span class="k">func</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">var</span> <span class="n">preOrder</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
    <span class="n">preOrder</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>  <span class="c">// root</span>
        <span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>          <span class="c">// left</span>
        <span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>         <span class="c">// right</span>
    <span class="p">}</span>
    <span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="c">// Iterate</span>
<span class="k">func</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>

    <span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>     <span class="c">// root</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>                <span class="c">// left</span>
        <span class="p">}</span>
        <span class="c">// pop</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="n">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span>                  <span class="c">// right</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="inorder">Inorder</h1> <p>Access order: <code class="language-plaintext highlighter-rouge">Left -&gt; Root -&gt; Right</code></p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Recursion</span>
<span class="k">func</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">var</span> <span class="n">inorder</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
    <span class="n">inorder</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>          <span class="c">// left</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>  <span class="c">// root</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>         <span class="c">// right</span>
    <span class="p">}</span>
    <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="c">// Iterate</span>
<span class="k">func</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>

    <span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>            <span class="c">// left</span>
        <span class="p">}</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="n">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>    <span class="c">// root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span>              <span class="c">// right</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="postorder">Postorder</h1> <p>Access order: <code class="language-plaintext highlighter-rouge">Left -&gt; Right -&gt; Root</code></p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Recursion</span>
<span class="k">func</span> <span class="n">postorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">var</span> <span class="n">postorder</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
    <span class="n">postorder</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>          <span class="c">// left</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>         <span class="c">// right</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>   <span class="c">// root</span>
    <span class="p">}</span>
    <span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="c">// Iterate</span>
<span class="k">func</span> <span class="n">postorderTraversal</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>

    <span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="c">// will check if right node has been pop</span>
    <span class="k">var</span> <span class="n">lastVisit</span> <span class="o">*</span><span class="n">TreeNode</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>                                <span class="c">// left</span>
        <span class="p">}</span>

        <span class="n">node</span> <span class="o">:=</span> <span class="n">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
        <span class="c">// root will pop after right node</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span> <span class="o">==</span> <span class="n">lastVisit</span> <span class="p">{</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>                   <span class="c">// root</span>
            <span class="n">lastVisit</span> <span class="o">=</span> <span class="n">node</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span>                             <span class="c">// right</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="levelorder">Levelorder</h1> <p>Access order: <code class="language-plaintext highlighter-rouge">from left to right, level by level</code></p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Recursion (BFS)</span>
<span class="k">func</span> <span class="n">levelorder</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">var</span> <span class="n">bfs</span> <span class="k">func</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">dep</span> <span class="kt">int</span><span class="p">)</span>
    <span class="n">bfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">dep</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="n">dep</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{})</span>
        <span class="p">}</span>
        <span class="n">res</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">dep</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
        <span class="n">bfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span> <span class="n">dep</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
        <span class="n">bfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span> <span class="n">dep</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="c">// Iterate</span>
<span class="k">func</span> <span class="n">levelorder</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c">// Time complexity: O(n)</span>
    <span class="c">// Spatial complexity: O(n)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="p">}</span>

    <span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">root</span><span class="p">}</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">next</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">{}</span>
        <span class="n">vals</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">curr</span> <span class="p">{</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span> <span class="c">// add curr level node val</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="algo"/><category term="code"/><summary type="html"><![CDATA[Binary Tree preorder, inorder, postorder and levelorder.]]></summary></entry></feed>